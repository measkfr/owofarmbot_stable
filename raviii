import asyncio
import logging
from datetime import datetime, timedelta
from telegram import Update
from telegram.ext import Application, CommandHandler, CallbackContext
from telegram.constants import ParseMode
import random

# Enable logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ==================== QUOTES DATABASE ====================
QUOTES = {
    'time_based': [
        "â³ Time is the most valuable currency - spend it wisely.",
        "ğŸ•°ï¸ Don't watch the clock; do what it does. Keep going.",
        "â° The bad news is time flies. The good news is you're the pilot.",
        "ğŸ“… Yesterday is history, tomorrow is a mystery, today is a gift.",
        "ğŸŒ… Each sunrise brings new opportunities; each sunset brings reflection.",
        "ğŸ”„ Time doesn't change us, it just unfolds us.",
        "ğŸ¯ The key is not to prioritize what's on your schedule, but to schedule your priorities.",
        "âš¡ Lost time is never found again.",
        "ğŸŒ™ The night is darkest just before the dawn.",
        "ğŸŒ Make each day your masterpiece."
    ],
    'life_based': [
        "ğŸŒ± Life is not about waiting for the storm to pass, but learning to dance in the rain.",
        "ğŸ¦‹ Just when the caterpillar thought the world was over, it became a butterfly.",
        "ğŸŒˆ After every storm, there is a rainbow of hope.",
        "ğŸ­ Life is a journey to be experienced, not a problem to be solved.",
        "ğŸŒŠ Life is like the ocean - it can be calm or rough, but it's always beautiful.",
        "ğŸŒ³ The best time to plant a tree was 20 years ago. The second best time is now.",
        "ğŸŒŸ You are never too old to set another goal or to dream a new dream.",
        "ğŸš€ Life begins at the end of your comfort zone.",
        "ğŸ’ We are all diamonds in the rough, being polished by life's challenges.",
        "ğŸŒ» Bloom where you are planted."
    ],
    'emotional': [
        "ğŸ’– The heart that loves is always young.",
        "ğŸ˜Š Happiness is not something ready-made. It comes from your own actions.",
        "ğŸ¤— Sometimes the smallest step in the right direction ends up being the biggest step of your life.",
        "ğŸŒŒ Even the darkest night will end and the sun will rise.",
        "ğŸ¤ Alone we can do so little; together we can do so much.",
        "ğŸ¶ Where words fail, music speaks.",
        "ğŸ•Šï¸ Peace begins with a smile.",
        "âœ¨ You are braver than you believe, stronger than you seem, and smarter than you think.",
        "ğŸŒ· Every flower must grow through dirt.",
        "ğŸ The most precious things in life are not things, but moments."
    ]
}

# ==================== HELPER FUNCTIONS ====================
def get_progress_bar(percentage, bar_length=20):
    """Create simple progress bar"""
    filled = int(round(bar_length * percentage / 100))
    empty = bar_length - filled
    
    # Simple block characters
    bar = f"â–ˆ" * filled + "â–‘" * empty
    return bar

def get_year_progress():
    """Calculate year progress percentage"""
    now = datetime.now()
    start = datetime(now.year, 1, 1)
    end = datetime(now.year + 1, 1, 1)
    total_seconds = (end - start).total_seconds()
    elapsed_seconds = (now - start).total_seconds()
    percentage = (elapsed_seconds / total_seconds) * 100
    return min(percentage, 100)

def get_day_progress():
    """Calculate day progress percentage"""
    now = datetime.now()
    start = datetime(now.year, now.month, now.day)
    end = start + timedelta(days=1)
    total_seconds = (end - start).total_seconds()
    elapsed_seconds = (now - start).total_seconds()
    percentage = (elapsed_seconds / total_seconds) * 100
    return min(percentage, 100)

def get_second_progress():
    """Calculate second progress within current minute"""
    now = datetime.now()
    seconds = now.second
    percentage = (seconds / 59) * 100
    return min(percentage, 100)

def get_month_info():
    """Get current month and days left"""
    now = datetime.now()
    month_name = now.strftime("%B")
    
    # Days left in month
    if now.month == 12:
        next_month = datetime(now.year + 1, 1, 1)
    else:
        next_month = datetime(now.year, now.month + 1, 1)
    
    days_in_month = (next_month - datetime(now.year, now.month, 1)).days
    days_left = days_in_month - now.day
    
    # Months left in year
    months_left = 12 - now.month
    
    return month_name, days_left, months_left

def get_random_quote():
    """Get a random quote based on current minute"""
    now = datetime.now()
    minute = now.minute
    
    # Select category based on hour
    hour = now.hour
    if 5 <= hour < 12:  # Morning
        categories = ['time_based', 'life_based']
    elif 12 <= hour < 17:  # Afternoon
        categories = ['life_based', 'emotional']
    else:  # Evening/Night
        categories = ['emotional', 'time_based']
    
    category = categories[minute % len(categories)]
    quote_index = minute % len(QUOTES[category])
    
    return QUOTES[category][quote_index]

# ==================== MESSAGE GENERATOR ====================
def generate_progress_message(update_count=0):
    """Generate the complete progress message"""
    # Get all progress data
    year_progress = get_year_progress()
    day_progress = get_day_progress()
    second_progress = get_second_progress()
    month_name, days_left, months_left = get_month_info()
    quote = get_random_quote()
    
    now = datetime.now()
    
    # Simple progress bars
    year_bar = get_progress_bar(year_progress)
    day_bar = get_progress_bar(day_progress)
    second_bar = get_progress_bar(second_progress)
    
    # Create message
    message = f"""
â° **LIVE TIME PROGRESS** â°
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“… **YEAR {now.year} PROGRESS**
{year_bar}
`{year_progress:.6f}%` completed

ğŸŒ **TODAY'S PROGRESS** 
{day_bar}
`{day_progress:.6f}%` completed

â±ï¸ **SECOND PROGRESS**
{second_bar}
`{second_progress:.2f}%` completed

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ—“ï¸ **MONTH INFORMATION**
â”œ Current Month: `{month_name}`
â”œ Days Remaining: `{days_left} days`
â”” Months Remaining: `{months_left} months`

â° **CURRENT TIME**
â”œ Date: `{now.strftime("%d %b %Y")}`
â”œ Time: `{now.strftime("%H:%M:%S")}`
â”” Second: `{now.second}`
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ’­ **QUOTE OF THE MINUTE**
_{quote}_
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”„ Updates every 5 seconds DevLoper :- @ravi_chad
    """
    
    return message.strip()

# ==================== EDIT MESSAGE FUNCTION ====================
async def update_message_continuously(chat_id: int, message_id: int, context: CallbackContext):
    """Continuously edit the same message with updated progress"""
    update_count = 0
    
    while context.chat_data.get(f'is_running_{chat_id}', False):
        try:
            # Generate new message
            new_message = generate_progress_message(update_count)
            
            # Edit the existing message
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=new_message,
                parse_mode=ParseMode.MARKDOWN
            )
            
            update_count += 1
            
            # Wait for 5 seconds to avoid flood control
            # Telegram limit: max 20 messages per minute per chat
            await asyncio.sleep(5)
            
        except Exception as e:
            # If message editing fails, stop the loop
            if "message to edit not found" in str(e) or "Message can't be edited" in str(e):
                logger.info(f"Stopping updates for chat {chat_id}, message was deleted")
                context.chat_data[f'is_running_{chat_id}'] = False
                break
            
            # If flood control error, wait longer
            if "Flood control" in str(e) or "429" in str(e):
                logger.warning(f"Flood control hit, waiting 30 seconds")
                await asyncio.sleep(30)
            else:
                logger.error(f"Error updating message: {e}")
                await asyncio.sleep(10)

# ==================== BOT HANDLERS ====================
async def start(update: Update, context: CallbackContext):
    """Send welcome message"""
    user = update.effective_user
    welcome_msg = f"""
ğŸ‘‹ **Welcome {user.first_name}!**

I'm **Live Time Progress Bot** â³

I show real-time progress with simple, clean bars:
â€¢ ğŸ“… Year progress with percentage
â€¢ ğŸŒ Day progress with percentage  
â€¢ â±ï¸ Second-by-second progress
â€¢ ğŸ—“ï¸ Month information
â€¢ ğŸ’­ Quotes that change every minute

**Features:**
âš¡ Updates every 5 seconds
ğŸ¯ Simple progress bars (â–ˆ â–‘)
ğŸ”„ Single message continuously updated
ğŸ“Š Accurate time calculations

Click /progress to begin! ğŸš€
    """
    
    await update.message.reply_text(welcome_msg, parse_mode=ParseMode.MARKDOWN)

async def progress(update: Update, context: CallbackContext):
    """Start the live progress updates in a single message"""
    chat_id = update.effective_chat.id
    
    # Check if already running
    if context.chat_data.get(f'is_running_{chat_id}', False):
        await update.message.reply_text("â³ Live progress is already running! Use /stop to end it.")
        return
    
    # Send initial message
    initial_msg = "ğŸ”„ **Starting Live Progress...**\n\n" + generate_progress_message()
    msg = await update.message.reply_text(
        initial_msg,
        parse_mode=ParseMode.MARKDOWN
    )
    
    # Store message ID and set running flag
    context.chat_data[f'last_msg_id_{chat_id}'] = msg.message_id
    context.chat_data[f'is_running_{chat_id}'] = True
    
    # Start the continuous update loop
    asyncio.create_task(
        update_message_continuously(
            chat_id, 
            msg.message_id, 
            context
        )
    )
    
    await update.message.reply_text(
        "âœ… **Live Progress Started!**\n\n"
        "The progress is now updating every 5 seconds!\n"
        "Watch the bars grow in real-time â±ï¸\n\n"
        "Use /stop to end updates.",
        parse_mode=ParseMode.MARKDOWN
    )

async def stop(update: Update, context: CallbackContext):
    """Stop the live progress updates"""
    chat_id = update.effective_chat.id
    
    if context.chat_data.get(f'is_running_{chat_id}', False):
        context.chat_data[f'is_running_{chat_id}'] = False
        await update.message.reply_text(
            "â¹ï¸ **Live Progress Stopped**\n\n"
            "The updates have been paused.\n"
            "Use /progress to start again!",
            parse_mode=ParseMode.MARKDOWN
        )
    else:
        await update.message.reply_text(
            "â„¹ï¸ No active live progress found.\n"
            "Use /progress to start one!",
            parse_mode=ParseMode.MARKDOWN
        )

async def stats(update: Update, context: CallbackContext):
    """Show current stats once"""
    message = generate_progress_message()
    await update.message.reply_text(message, parse_mode=ParseMode.MARKDOWN)

async def help_command(update: Update, context: CallbackContext):
    """Send help message"""
    help_text = """
ğŸ¤– **Live Time Progress Bot Help**

**Commands:**
/start - Welcome message
/progress - Start live updates (single message)
/stop - Stop live updates
/stats - Show current stats once
/help - Show this help

**Features:**
â€¢ ğŸ“… **Year Progress**: Simple bar with percentage
â€¢ ğŸŒ **Day Progress**: Clean bar showing day progress  
â€¢ â±ï¸ **Second Progress**: Real-time second tracking
â€¢ ğŸ¯ **Single Message**: No deletion, continuous editing
â€¢ ğŸ’­ **Smart Quotes**: Changes every minute
â€¢ âš¡ **5-second Updates**: Safe from flood control

**How it works:**
â€¢ Single message stays and updates every 5 seconds
â€¢ Simple progress bars using â–ˆ and â–‘ characters
â€¢ Safe update interval to avoid Telegram limits
â€¢ All calculations in real-time

**Enjoy watching time progress!** â³
    """
    await update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN)

# ==================== MAIN FUNCTION ====================
def main():
    """Start the bot"""
    # Bot Token (Replace with your actual token)
    TOKEN = "YOUR_BOT_TOKEN_HERE"
    
    # Create Application
    application = Application.builder().token(TOKEN).build()
    
    # Add command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("progress", progress))
    application.add_handler(CommandHandler("stop", stop))
    application.add_handler(CommandHandler("stats", stats))
    application.add_handler(CommandHandler("help", help_command))
    
    # Start the Bot
    print("ğŸ¤– Bot is starting...")
    print("â³ Live Time Progress Bot")
    print("âš¡ Simple progress bars ready!")
    print("ğŸ”„ 5-second update interval")
    
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
